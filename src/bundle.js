/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var GlobalMiracle;
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/coordTransform.ts":
/*!*******************************!*\
  !*** ./src/coordTransform.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CoordTransform)\n/* harmony export */ });\n/* harmony import */ var _graphic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graphic */ \"./src/graphic.ts\");\n\r\nclass CoordTransform {\r\n    constructor(scale = 1) {\r\n        this.basePoint_world = new _graphic__WEBPACK_IMPORTED_MODULE_0__.Point(0, 0); // 基点（世界坐标系）,也是该图块自身的旋转中心\r\n        this.displacement = (vector) => {\r\n            this.basePoint_world = new _graphic__WEBPACK_IMPORTED_MODULE_0__.Point(this.basePoint_world.x + vector.x, this.basePoint_world.y + vector.y);\r\n        };\r\n        /**\r\n         * 将世界坐标系点转换为设备坐标点\r\n         * @param pointW\r\n         */\r\n        this.worldToDevice_Point = (pointW) => {\r\n            const dx = pointW.x * 1 / this._worldToDevice_Len_X;\r\n            const dy = pointW.y * 1 / this._worldToDevice_Len_Y;\r\n            // 处理旋转角度\r\n            const pointNotRotate = new _graphic__WEBPACK_IMPORTED_MODULE_0__.Point(dx, dy);\r\n            const pointNotRotate_polar = _graphic__WEBPACK_IMPORTED_MODULE_0__.GraphicsAssist.cartesianToPolar(pointNotRotate);\r\n            const pointRotate_polar = {\r\n                length: pointNotRotate_polar.length,\r\n                angle: pointNotRotate_polar.angle - this.anticlockwiseAngle // 因为屏幕坐标Y值向下，所以角度用减法表示逆时针旋转\r\n            };\r\n            const pointRotate = _graphic__WEBPACK_IMPORTED_MODULE_0__.GraphicsAssist.polarToCartesian(pointRotate_polar);\r\n            return new _graphic__WEBPACK_IMPORTED_MODULE_0__.Point(this.basePoint_world.x + pointRotate.x, this.basePoint_world.y + pointRotate.y);\r\n        };\r\n        /**\r\n         * 缩放\r\n         * @param deviceZoomOrigin 缩放中心（设备坐标系）\r\n         * @param zoomScale 缩放比例\r\n         */\r\n        this.zoom = (deviceZoomOrigin, zoomScale) => {\r\n            // 因为引入了角度，所以如果要改变x（主方向）和y（副方向）方向，需要将deviceZoomOrigin先恢复到angle为0的点\r\n            const newOrigin = _graphic__WEBPACK_IMPORTED_MODULE_0__.GraphicsAssist.rotatePoint(this.basePoint_world, deviceZoomOrigin, -this.anticlockwiseAngle);\r\n            this._worldToDevice_Len_X = this._worldToDevice_Len_X * 1 / zoomScale;\r\n            this._worldToDevice_Len_Y = this._worldToDevice_Len_Y * 1 / zoomScale;\r\n            let dx = this.basePoint_world.x - newOrigin.x;\r\n            dx *= zoomScale;\r\n            let dy = this.basePoint_world.y - newOrigin.y;\r\n            dy *= zoomScale;\r\n            // 主方向长度增加了dx长度，即basePoint_world向主方向平移了dx长度\r\n            const pointPolar = {\r\n                length: dx,\r\n                angle: -this.anticlockwiseAngle\r\n            };\r\n            const point = _graphic__WEBPACK_IMPORTED_MODULE_0__.GraphicsAssist.polarToCartesian(pointPolar);\r\n            // 副方向长度增加了dy长度，即basePoint_world向副方向平移了dx长度\r\n            const pointPolar2 = {\r\n                length: dy,\r\n                angle: -this.anticlockwiseAngle + Math.PI * 0.5\r\n            };\r\n            const point2 = _graphic__WEBPACK_IMPORTED_MODULE_0__.GraphicsAssist.polarToCartesian(pointPolar2);\r\n            this.basePoint_world = new _graphic__WEBPACK_IMPORTED_MODULE_0__.Point(deviceZoomOrigin.x + point.x + point2.x, deviceZoomOrigin.y + point.y + point2.y);\r\n        };\r\n        /**\r\n         * 缩放主方向（X方向）,副方向（Y方向）不变\r\n         * @param deviceZoomOrigin 缩放中心\r\n         * @param zoomScale 缩放比例\r\n         */\r\n        this.zoomX = (deviceZoomOrigin, zoomScale) => {\r\n            // 因为引入了角度，所以如果要改变x（主方向）和y（副方向）方向，需要将deviceZoomOrigin先恢复到angle为0的点\r\n            const newOrigin = _graphic__WEBPACK_IMPORTED_MODULE_0__.GraphicsAssist.rotatePoint(this.basePoint_world, deviceZoomOrigin, -this.anticlockwiseAngle);\r\n            this._worldToDevice_Len_X = this._worldToDevice_Len_X * 1 / zoomScale;\r\n            let dx = this.basePoint_world.x - newOrigin.x;\r\n            dx *= zoomScale;\r\n            // 主方向长度增加了dx长度，即basePoint_world向主方向平移了dx长度\r\n            const pointPolar = {\r\n                length: dx,\r\n                angle: -this.anticlockwiseAngle\r\n            };\r\n            const point = _graphic__WEBPACK_IMPORTED_MODULE_0__.GraphicsAssist.polarToCartesian(pointPolar);\r\n            this.basePoint_world = new _graphic__WEBPACK_IMPORTED_MODULE_0__.Point(deviceZoomOrigin.x + point.x, deviceZoomOrigin.y + point.y);\r\n        };\r\n        /**\r\n         * 缩放副方向（Y方向），主方向（X方向）不变\r\n         * @param deviceZoomOrigin 缩放中心\r\n         * @param zoomScale 缩放比例\r\n         */\r\n        this.zoomY = (deviceZoomOrigin, zoomScale) => {\r\n            // 因为引入了角度，所以如果要改变x（主方向）和y（副方向）方向，需要将deviceZoomOrigin先恢复到angle为0的点\r\n            const newOrigin = _graphic__WEBPACK_IMPORTED_MODULE_0__.GraphicsAssist.rotatePoint(this.basePoint_world, deviceZoomOrigin, -this.anticlockwiseAngle);\r\n            this._worldToDevice_Len_Y = this._worldToDevice_Len_Y * 1 / zoomScale;\r\n            // 更改基点位置\r\n            let dy = this.basePoint_world.y - newOrigin.y;\r\n            dy *= zoomScale;\r\n            // 副方向长度增加了dy长度，即basePoint_world向副方向平移了dx长度\r\n            const pointPolar = {\r\n                length: dy,\r\n                angle: -this.anticlockwiseAngle + Math.PI * 0.5\r\n            };\r\n            const point = _graphic__WEBPACK_IMPORTED_MODULE_0__.GraphicsAssist.polarToCartesian(pointPolar);\r\n            this.basePoint_world = new _graphic__WEBPACK_IMPORTED_MODULE_0__.Point(deviceZoomOrigin.x + point.x, deviceZoomOrigin.y + point.y);\r\n        };\r\n        this.rotateAnticlockwise = (angle) => {\r\n            this.anticlockwiseAngle += angle;\r\n            this.anticlockwiseAngle %= 2 * Math.PI;\r\n        };\r\n        this._worldToDevice_Len_X = 1 / scale;\r\n        this._worldToDevice_Len_Y = 1 / scale;\r\n        this.anticlockwiseAngle = 0;\r\n    }\r\n    /**\r\n     * 设置基点（图的旋转中心）\r\n     * @param point\r\n     */\r\n    get base() {\r\n        return this.basePoint_world;\r\n    }\r\n    set base(value) {\r\n        this.basePoint_world = value;\r\n    }\r\n    get worldToDevice_Len_X() {\r\n        return this._worldToDevice_Len_X;\r\n    }\r\n    get worldToDevice_Len_Y() {\r\n        return this._worldToDevice_Len_Y;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://GlobalMiracle/./src/coordTransform.ts?");

/***/ }),

/***/ "./src/entity.ts":
/*!***********************!*\
  !*** ./src/entity.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Image\": () => (/* binding */ Image),\n/* harmony export */   \"Shape\": () => (/* binding */ Shape),\n/* harmony export */   \"PolyShape\": () => (/* binding */ PolyShape),\n/* harmony export */   \"Circle\": () => (/* binding */ Circle),\n/* harmony export */   \"EntityCollection\": () => (/* binding */ EntityCollection),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _graphic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graphic */ \"./src/graphic.ts\");\n/* harmony import */ var _coordTransform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./coordTransform */ \"./src/coordTransform.ts\");\n\r\n\r\nvar ControlStyle;\r\n(function (ControlStyle) {\r\n    ControlStyle[ControlStyle[\"Rectangle\"] = 1] = \"Rectangle\";\r\n    ControlStyle[ControlStyle[\"Circle\"] = 2] = \"Circle\";\r\n})(ControlStyle || (ControlStyle = {}));\r\nclass Entity {\r\n    constructor() {\r\n        /**\r\n         * 是否处于激活状态\r\n         */\r\n        this.isActive = false;\r\n        /**\r\n         * 是否可见\r\n         */\r\n        this.visible = true;\r\n        /**\r\n         * 是否绘制控制点\r\n         */\r\n        this.isDrawControlPoint = true;\r\n        /**\r\n         * x方向缩放是否禁用\r\n         */\r\n        this.xLocked = false;\r\n        /**\r\n         * y方向缩放是否禁用\r\n         */\r\n        this.yLocked = false;\r\n        /**\r\n         * 对角线缩放是否禁用\r\n         */\r\n        this.diagLocked = false;\r\n        /**\r\n         * 旋转是否禁用\r\n         */\r\n        this.rotateLocked = false;\r\n        /**\r\n         * 控制点样式\r\n         */\r\n        this.controlStyle = ControlStyle.Circle;\r\n        /**\r\n         * 控制点大小\r\n         */\r\n        this.controlSize = 20;\r\n        /**\r\n         * 选中时边框样式\r\n         */\r\n        this.borderStyle = \"#007acc\";\r\n        /**\r\n         * 选中时边框线宽\r\n         */\r\n        this.borderWidth = 2;\r\n        /**\r\n         * 旋转点距离包围框矩形的距离\r\n         */\r\n        this.rotateControlDistance = 40;\r\n        /**\r\n         * 是否绘制自定义按钮\r\n         */\r\n        this.isDrawControl = true;\r\n        /**\r\n         * 自定义控件（按钮）\r\n         */\r\n        this._controls = [];\r\n        this.ctf = new _coordTransform__WEBPACK_IMPORTED_MODULE_1__.default(1);\r\n    }\r\n    /**\r\n     * 自定义控件（按钮）\r\n     */\r\n    get controls() {\r\n        return this._controls;\r\n    }\r\n    get rotateOrigin() {\r\n        return this.ctf.base;\r\n    }\r\n    addControl(...ctrs) {\r\n        ctrs.forEach((control) => {\r\n            control.owner = this;\r\n            this._controls.push(control);\r\n        });\r\n    }\r\n    draw(ctx) {\r\n        if (this.visible) {\r\n            this.drawContent(ctx);\r\n            if (this.isActive) {\r\n                this.drawBound(ctx);\r\n                if (this.isDrawControlPoint) {\r\n                    this.drawControlPoint(ctx);\r\n                }\r\n                if (this.isDrawControl) {\r\n                    for (let i = 0; i < this._controls.length; i++) {\r\n                        this._controls[i].draw(ctx);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 包围框（世界坐标系）\r\n     * 这个每次获得，都要重新计算包围框，大大降低了效率，后期考虑改进\r\n     */\r\n    get boundWorld() {\r\n        return this.getBoundWorld();\r\n    }\r\n    /**\r\n     * 包围框（屏幕坐标系）\r\n     */\r\n    get bound() {\r\n        const boundW = this.getBoundWorld();\r\n        const locationW = _graphic__WEBPACK_IMPORTED_MODULE_0__.GraphicsAssist.mid(boundW.lt, boundW.rd);\r\n        const locationD = this.ctf.worldToDevice_Point(locationW);\r\n        const widthD = boundW.width * 1 / this.ctf.worldToDevice_Len_X;\r\n        const heightD = boundW.height * 1 / this.ctf.worldToDevice_Len_Y;\r\n        const boundD = new _graphic__WEBPACK_IMPORTED_MODULE_0__.Rectangle(locationD, widthD, heightD);\r\n        boundD.angle = this.ctf.anticlockwiseAngle;\r\n        return boundD;\r\n    }\r\n    /**\r\n     * 获得left middle控制点包围框（设备坐标系）\r\n     */\r\n    getControlPointBound_lm_device() {\r\n        const controlPointW = _graphic__WEBPACK_IMPORTED_MODULE_0__.GraphicsAssist.mid(this.boundWorld.lt, this.boundWorld.ld);\r\n        const controlPointD = this.ctf.worldToDevice_Point(controlPointW);\r\n        return new _graphic__WEBPACK_IMPORTED_MODULE_0__.Rectangle(controlPointD, this.controlSize, this.controlSize);\r\n    }\r\n    /**\r\n     * 获得right middle控制点包围框（设备坐标系）\r\n     */\r\n    getControlPointBound_rm_device() {\r\n        const controlPointW = _graphic__WEBPACK_IMPORTED_MODULE_0__.GraphicsAssist.mid(this.boundWorld.rt, this.boundWorld.rd);\r\n        const controlPointD = this.ctf.worldToDevice_Point(controlPointW);\r\n        return new _graphic__WEBPACK_IMPORTED_MODULE_0__.Rectangle(controlPointD, this.controlSize, this.controlSize);\r\n    }\r\n    /**\r\n     * 获得top middle控制点包围框（设备坐标系）\r\n     */\r\n    getControlPointBound_tm_device() {\r\n        const controlPointW = _graphic__WEBPACK_IMPORTED_MODULE_0__.GraphicsAssist.mid(this.boundWorld.lt, this.boundWorld.rt);\r\n        const controlPointD = this.ctf.worldToDevice_Point(controlPointW);\r\n        return new _graphic__WEBPACK_IMPORTED_MODULE_0__.Rectangle(controlPointD, this.controlSize, this.controlSize);\r\n    }\r\n    /**\r\n     * 获得bottom middle控制点包围框（设备坐标系）\r\n     */\r\n    getControlPointBound_bm_device() {\r\n        const controlPointW = _graphic__WEBPACK_IMPORTED_MODULE_0__.GraphicsAssist.mid(this.boundWorld.ld, this.boundWorld.rd);\r\n        const controlPointD = this.ctf.worldToDevice_Point(controlPointW);\r\n        return new _graphic__WEBPACK_IMPORTED_MODULE_0__.Rectangle(controlPointD, this.controlSize, this.controlSize);\r\n    }\r\n    /**\r\n     * 获得left top控制点包围框（设备坐标系）\r\n     */\r\n    getControlPointBound_lt_device() {\r\n        const controlPointW = this.boundWorld.lt;\r\n        const controlPointD = this.ctf.worldToDevice_Point(controlPointW);\r\n        return new _graphic__WEBPACK_IMPORTED_MODULE_0__.Rectangle(controlPointD, this.controlSize, this.controlSize);\r\n    }\r\n    /**\r\n     * 获得left top控制点包围框（设备坐标系）\r\n     */\r\n    getControlPointBound_rt_device() {\r\n        const controlPointW = this.boundWorld.rt;\r\n        const controlPointD = this.ctf.worldToDevice_Point(controlPointW);\r\n        return new _graphic__WEBPACK_IMPORTED_MODULE_0__.Rectangle(controlPointD, this.controlSize, this.controlSize);\r\n    }\r\n    /**\r\n     * 获得left bottom控制点包围框（设备坐标系）\r\n     */\r\n    getControlPointBound_lb_device() {\r\n        const controlPointW = this.boundWorld.ld;\r\n        const controlPointD = this.ctf.worldToDevice_Point(controlPointW);\r\n        return new _graphic__WEBPACK_IMPORTED_MODULE_0__.Rectangle(controlPointD, this.controlSize, this.controlSize);\r\n    }\r\n    /**\r\n     * 获得right bottom控制点包围框（设备坐标系）\r\n     */\r\n    getControlPointBound_rb_device() {\r\n        const controlPointW = this.boundWorld.rd;\r\n        const controlPointD = this.ctf.worldToDevice_Point(controlPointW);\r\n        return new _graphic__WEBPACK_IMPORTED_MODULE_0__.Rectangle(controlPointD, this.controlSize, this.controlSize);\r\n    }\r\n    /**\r\n     * 获得旋转控制点包围框（设备坐标系）\r\n     */\r\n    getControlPointBound_rotate_device() {\r\n        const tm = _graphic__WEBPACK_IMPORTED_MODULE_0__.GraphicsAssist.mid(this.boundWorld.lt, this.boundWorld.rt);\r\n        const controlPointW = new _graphic__WEBPACK_IMPORTED_MODULE_0__.Point(tm.x, tm.y - this.rotateControlDistance);\r\n        const controlPointD = this.ctf.worldToDevice_Point(controlPointW);\r\n        return new _graphic__WEBPACK_IMPORTED_MODULE_0__.Rectangle(controlPointD, this.controlSize, this.controlSize);\r\n    }\r\n    /**\r\n     * 绘制包围框\r\n     */\r\n    drawBound(ctx) {\r\n        const boundRect = this.boundWorld;\r\n        ctx.strokeStyle = this.borderStyle;\r\n        ctx.lineWidth = this.borderWidth;\r\n        // 绘制边界\r\n        const boundRectLtd = this.ctf.worldToDevice_Point(boundRect.lt);\r\n        const boundRectLdd = this.ctf.worldToDevice_Point(boundRect.ld);\r\n        const boundRectRtd = this.ctf.worldToDevice_Point(boundRect.rt);\r\n        const boundRectRdd = this.ctf.worldToDevice_Point(boundRect.rd);\r\n        ctx.beginPath();\r\n        ctx.moveTo(boundRectLtd.x, boundRectLtd.y);\r\n        ctx.lineTo(boundRectLdd.x, boundRectLdd.y);\r\n        ctx.lineTo(boundRectRdd.x, boundRectRdd.y);\r\n        ctx.lineTo(boundRectRtd.x, boundRectRtd.y);\r\n        ctx.closePath();\r\n        ctx.stroke();\r\n    }\r\n    /**\r\n     * 绘制控制点\r\n     */\r\n    drawControlPoint(ctx) {\r\n        /**绘制一个控制点 */\r\n        const drawControlPoint = (ctx, worldPoint) => {\r\n            switch (this.controlStyle) {\r\n                case ControlStyle.Rectangle:\r\n                    // 设备坐标点\r\n                    const devicePoint = this.ctf.worldToDevice_Point(worldPoint);\r\n                    const ltd = new _graphic__WEBPACK_IMPORTED_MODULE_0__.Point(devicePoint.x - this.controlSize * 0.5, devicePoint.y - this.controlSize * 0.5);\r\n                    const ldd = new _graphic__WEBPACK_IMPORTED_MODULE_0__.Point(devicePoint.x - this.controlSize * 0.5, devicePoint.y + this.controlSize * 0.5);\r\n                    const rdd = new _graphic__WEBPACK_IMPORTED_MODULE_0__.Point(devicePoint.x + this.controlSize * 0.5, devicePoint.y + this.controlSize * 0.5);\r\n                    const rtd = new _graphic__WEBPACK_IMPORTED_MODULE_0__.Point(devicePoint.x + this.controlSize * 0.5, devicePoint.y - this.controlSize * 0.5);\r\n                    // 绘制\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(ltd.x, ltd.y);\r\n                    ctx.lineTo(ldd.x, ldd.y);\r\n                    ctx.lineTo(rdd.x, rdd.y);\r\n                    ctx.lineTo(rtd.x, rtd.y);\r\n                    ctx.closePath();\r\n                    ctx.fill();\r\n                    break;\r\n                case ControlStyle.Circle:\r\n                    const ow = worldPoint;\r\n                    const od = this.ctf.worldToDevice_Point(ow);\r\n                    const sizeD = this.controlSize * 0.5;\r\n                    ctx.beginPath();\r\n                    ctx.ellipse(od.x, od.y, sizeD * 0.5, sizeD * 0.5, 0, 0, 2 * Math.PI);\r\n                    ctx.fill();\r\n                    break;\r\n                default:\r\n                    throw new Error(\"unknow control style.\");\r\n            }\r\n        };\r\n        const boundRect = this.boundWorld;\r\n        ctx.strokeStyle = this.borderStyle;\r\n        ctx.fillStyle = this.borderStyle;\r\n        ctx.lineWidth = this.borderWidth;\r\n        // 绘制x控制点\r\n        if (!this.xLocked) {\r\n            drawControlPoint(ctx, _graphic__WEBPACK_IMPORTED_MODULE_0__.GraphicsAssist.mid(boundRect.lt, boundRect.ld));\r\n            drawControlPoint(ctx, _graphic__WEBPACK_IMPORTED_MODULE_0__.GraphicsAssist.mid(boundRect.rt, boundRect.rd));\r\n        }\r\n        // 绘制y控制点\r\n        if (!this.yLocked) {\r\n            drawControlPoint(ctx, _graphic__WEBPACK_IMPORTED_MODULE_0__.GraphicsAssist.mid(boundRect.lt, boundRect.rt));\r\n            drawControlPoint(ctx, _graphic__WEBPACK_IMPORTED_MODULE_0__.GraphicsAssist.mid(boundRect.ld, boundRect.rd));\r\n        }\r\n        // 绘制顶点处控制点\r\n        if (!this.diagLocked) {\r\n            drawControlPoint(ctx, boundRect.lt);\r\n            drawControlPoint(ctx, boundRect.ld);\r\n            drawControlPoint(ctx, boundRect.rt);\r\n            drawControlPoint(ctx, boundRect.rd);\r\n        }\r\n        // 绘制旋转点\r\n        if (!this.rotateLocked) {\r\n            const tmW = _graphic__WEBPACK_IMPORTED_MODULE_0__.GraphicsAssist.mid(boundRect.lt, boundRect.rt);\r\n            const tmD = this.ctf.worldToDevice_Point(tmW);\r\n            const rotatePointW = new _graphic__WEBPACK_IMPORTED_MODULE_0__.Point(tmW.x, tmW.y - this.rotateControlDistance);\r\n            const rotatePointD = this.ctf.worldToDevice_Point(rotatePointW);\r\n            ctx.beginPath();\r\n            ctx.moveTo(tmD.x, tmD.y);\r\n            ctx.lineTo(rotatePointD.x, rotatePointD.y);\r\n            ctx.stroke();\r\n            drawControlPoint(ctx, rotatePointW);\r\n        }\r\n    }\r\n    /**\r\n     * 平移\r\n     */\r\n    displacement(vector) {\r\n        this.ctf.displacement(vector);\r\n    }\r\n    /**\r\n     * 缩放\r\n     */\r\n    zoom(originInDevice, scale) {\r\n        this.ctf.zoom(originInDevice, scale);\r\n    }\r\n    /**\r\n     * 缩放X方向\r\n     */\r\n    zoomX(originInDevice, scale) {\r\n        this.ctf.zoomX(originInDevice, scale);\r\n    }\r\n    /**\r\n     * 缩放Y方向\r\n     */\r\n    zoomY(originInDevice, scale) {\r\n        this.ctf.zoomY(originInDevice, scale);\r\n    }\r\n    /**\r\n     * 顺时针旋转\r\n     * @param originInDevice 旋转中心\r\n     * @param angle 旋转角度（弧度值）\r\n     */\r\n    rotateAnticlockwise(angle) {\r\n        this.ctf.rotateAnticlockwise(angle);\r\n    }\r\n    /**\r\n     * 转换成图片base64 dataurl\r\n     * @param scale 在当前大小的基础上在缩放一个比例值\r\n     * @param type （与HTMLCanvasElement.toDataURL的第一个参数相同）图片格式\r\n     * @param quality （与HTMLCanvasElement.toDataURL的第二个参数相同）在指定图片格式为 image/jpeg 或 image/webp的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 0.92。\r\n     */\r\n    toDataUrl(type, scale, quality) {\r\n        const canvas = document.createElement(\"canvas\");\r\n        let min_x = Math.min(this.bound.lt.x, this.bound.ld.x, this.bound.rt.x, this.bound.rd.x);\r\n        const max_x = Math.max(this.bound.lt.x, this.bound.ld.x, this.bound.rt.x, this.bound.rd.x);\r\n        let min_y = Math.min(this.bound.lt.y, this.bound.ld.y, this.bound.rt.y, this.bound.rd.y);\r\n        const max_y = Math.max(this.bound.lt.y, this.bound.ld.y, this.bound.rt.y, this.bound.rd.y);\r\n        const height = max_y - min_y;\r\n        const width = max_x - min_x;\r\n        if (scale) {\r\n            canvas.width = scale.x * width;\r\n            canvas.height = scale.y * height;\r\n            canvas.style.width = `${scale.x * width}px`;\r\n            canvas.style.height = `${scale.y * height}px`;\r\n        }\r\n        else {\r\n            canvas.width = width;\r\n            canvas.height = height;\r\n            canvas.style.width = `${width}px`;\r\n            canvas.style.height = `${height}px`;\r\n        }\r\n        const ctx = canvas.getContext(\"2d\");\r\n        if (scale) {\r\n            ctx === null || ctx === void 0 ? void 0 : ctx.scale(scale.x, scale.y);\r\n            ctx === null || ctx === void 0 ? void 0 : ctx.translate(-min_x, -min_y);\r\n        }\r\n        else {\r\n            ctx === null || ctx === void 0 ? void 0 : ctx.translate(-min_x, -min_y);\r\n        }\r\n        if (ctx) {\r\n            this.drawContent(ctx);\r\n            ctx.resetTransform();\r\n        }\r\n        return canvas.toDataURL(type, quality);\r\n    }\r\n}\r\n/**\r\n * 图片\r\n */\r\nclass Image extends Entity {\r\n    constructor(position, src, size) {\r\n        super();\r\n        this.position = position;\r\n        this.src = src;\r\n        let image = new window.Image();\r\n        if (size) {\r\n            image = new window.Image(size.width, size.height);\r\n        }\r\n        image.src = src;\r\n        this._image = image;\r\n        this.setRotateOrigin(new _graphic__WEBPACK_IMPORTED_MODULE_0__.Point(this.position.x + 0.5 * this.width, this.position.y + 0.5 * this.height));\r\n    }\r\n    get width() {\r\n        return this._image.width;\r\n    }\r\n    get height() {\r\n        return this._image.height;\r\n    }\r\n    /**\r\n     * _image是否load\r\n     */\r\n    get imgLoaded() {\r\n        return this._image ? this._image.complete && this._image.naturalHeight !== 0 : false;\r\n    }\r\n    drawContent(ctx) {\r\n        const draw = () => {\r\n            const width = 1 / this.ctf.worldToDevice_Len_X * this.width;\r\n            const height = 1 / this.ctf.worldToDevice_Len_Y * this.height;\r\n            const x = this.position.x * 1 / this.ctf.worldToDevice_Len_X;\r\n            const y = this.position.y * 1 / this.ctf.worldToDevice_Len_Y;\r\n            ctx.translate(this.ctf.base.x, this.ctf.base.y);\r\n            ctx.rotate(-this.ctf.anticlockwiseAngle);\r\n            ctx.drawImage(this._image, x, y, width, height);\r\n            ctx.resetTransform();\r\n        };\r\n        if (this.imgLoaded) {\r\n            draw();\r\n        }\r\n        else {\r\n            this._image.onload = () => {\r\n                draw();\r\n            };\r\n        }\r\n    }\r\n    getBoundWorld() {\r\n        return new _graphic__WEBPACK_IMPORTED_MODULE_0__.Rectangle(new _graphic__WEBPACK_IMPORTED_MODULE_0__.Point(this.position.x + 0.5 * this.width, this.position.y + 0.5 * this.height), this.width, this.height);\r\n    }\r\n    setRotateOrigin(originW) {\r\n        const dx = this.position.x - originW.x;\r\n        const dy = this.position.y - originW.y;\r\n        this.position = new _graphic__WEBPACK_IMPORTED_MODULE_0__.Point(dx, dy);\r\n        this.ctf.base = originW;\r\n    }\r\n}\r\n/**\r\n * 形状\r\n */\r\nclass Shape extends Entity {\r\n    constructor() {\r\n        super();\r\n        this.lineW = 1;\r\n        this.strokeStyle = \"red\";\r\n        this.fillStyle = \"red\";\r\n        this.filled = false;\r\n    }\r\n}\r\n/**\r\n * 多义线形状,是一个形状，可以是一个多义线，但是不能是一条直线段。\r\n */\r\nclass PolyShape extends Shape {\r\n    constructor(vertexs, closed = false) {\r\n        super();\r\n        this.vertexs = vertexs;\r\n        this.closed = closed;\r\n        this.setRotateOrigin(_graphic__WEBPACK_IMPORTED_MODULE_0__.GraphicsAssist.mid(this.boundWorld.lt, this.boundWorld.rd));\r\n    }\r\n    /**\r\n     * 在canvas上绘制图形\r\n     */\r\n    drawContent(ctx) {\r\n        if (this.vertexs.length <= 2) {\r\n            throw new Error(\"the count of vertex must greater then 2.\");\r\n        }\r\n        // 改变样式\r\n        ctx.strokeStyle = this.strokeStyle;\r\n        ctx.fillStyle = this.fillStyle;\r\n        ctx.lineWidth = this.lineW;\r\n        // 转换顶点\r\n        let points = [];\r\n        this.vertexs.forEach((vertex) => {\r\n            points.push(this.ctf.worldToDevice_Point(vertex));\r\n        });\r\n        // 绘制\r\n        if (this.filled) {\r\n            ctx.beginPath();\r\n            ctx.moveTo(points[0].x, points[0].y);\r\n            for (let i = 1; i < points.length; i++) {\r\n                ctx.lineTo(points[i].x, points[i].y);\r\n            }\r\n            ctx.fill();\r\n        }\r\n        else {\r\n            ctx.beginPath();\r\n            ctx.moveTo(points[0].x, points[0].y);\r\n            for (let i = 1; i < points.length; i++) {\r\n                ctx.lineTo(points[i].x, points[i].y);\r\n            }\r\n            if (this.closed) {\r\n                ctx.closePath();\r\n            }\r\n            ctx.stroke();\r\n        }\r\n    }\r\n    /**\r\n     * 求包围框\r\n     */\r\n    getBoundWorld() {\r\n        return _graphic__WEBPACK_IMPORTED_MODULE_0__.Rectangle.bound(this.vertexs);\r\n    }\r\n    /**\r\n     * 设置旋转中心\r\n     */\r\n    setRotateOrigin(originW) {\r\n        for (let i = 0; i < this.vertexs.length; i++) {\r\n            const dx = this.vertexs[i].x - originW.x;\r\n            const dy = this.vertexs[i].y - originW.y;\r\n            this.vertexs[i] = new _graphic__WEBPACK_IMPORTED_MODULE_0__.Point(dx, dy);\r\n        }\r\n        this.ctf.base = originW;\r\n    }\r\n}\r\n/**\r\n * 圆形\r\n */\r\nclass Circle extends Shape {\r\n    constructor(center, radius1, radius2) {\r\n        super();\r\n        this.center = center;\r\n        this.radiusX = radius1;\r\n        this.radiusY = radius2 !== null && radius2 !== void 0 ? radius2 : radius1;\r\n        this.setRotateOrigin(_graphic__WEBPACK_IMPORTED_MODULE_0__.GraphicsAssist.mid(this.boundWorld.lt, this.boundWorld.rd));\r\n    }\r\n    drawContent(ctx) {\r\n        // 改变样式\r\n        ctx.strokeStyle = this.strokeStyle;\r\n        ctx.fillStyle = this.fillStyle;\r\n        ctx.lineWidth = this.lineW;\r\n        const o = this.ctf.worldToDevice_Point(this.center);\r\n        const r1 = 1 / this.ctf.worldToDevice_Len_X * this.radiusX;\r\n        const r2 = 1 / this.ctf.worldToDevice_Len_Y * this.radiusY;\r\n        ctx.translate(o.x, o.y);\r\n        ctx.rotate(-this.ctf.anticlockwiseAngle);\r\n        ctx.beginPath();\r\n        ctx.ellipse(0, 0, r1, r2, 0, 0, 2 * Math.PI);\r\n        ctx.resetTransform();\r\n        if (this.filled) {\r\n            ctx.fill();\r\n        }\r\n        else {\r\n            ctx.stroke();\r\n        }\r\n    }\r\n    /**\r\n     * 求包围框\r\n     */\r\n    getBoundWorld() {\r\n        return new _graphic__WEBPACK_IMPORTED_MODULE_0__.Rectangle(this.center, 2 * this.radiusX, 2 * this.radiusY);\r\n    }\r\n    setRotateOrigin(originW) {\r\n        const dx = this.center.x - originW.x;\r\n        const dy = this.center.y - originW.y;\r\n        this.center = new _graphic__WEBPACK_IMPORTED_MODULE_0__.Point(dx, dy);\r\n        this.ctf.base = originW;\r\n    }\r\n}\r\n/**\r\n * 一组entity的集合\r\n */\r\nclass EntityCollection extends Entity {\r\n    constructor(entities) {\r\n        super();\r\n        this.entities = entities;\r\n        this.ctf = new _coordTransform__WEBPACK_IMPORTED_MODULE_1__.default(1);\r\n        this.rotateLocked = true;\r\n        this.xLocked = true;\r\n        this.yLocked = true;\r\n        this.diagLocked = true;\r\n    }\r\n    drawContent(ctx) {\r\n        for (let i = 0; i < this.entities.length; i++) {\r\n            this.entities[i].draw(ctx);\r\n        }\r\n        if (this.isActive) {\r\n            this.drawBound(ctx);\r\n            if (this.isDrawControlPoint) {\r\n                this.drawControlPoint(ctx);\r\n            }\r\n        }\r\n    }\r\n    getBoundWorld() {\r\n        const boundsD = this.entities.map((ent) => ent.bound);\r\n        return _graphic__WEBPACK_IMPORTED_MODULE_0__.Rectangle.union(boundsD);\r\n    }\r\n    setRotateOrigin(originW) {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n}\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Entity);\r\n\n\n//# sourceURL=webpack://GlobalMiracle/./src/entity.ts?");

/***/ }),

/***/ "./src/graphic.ts":
/*!************************!*\
  !*** ./src/graphic.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Point\": () => (/* binding */ Point),\n/* harmony export */   \"Vector\": () => (/* binding */ Vector),\n/* harmony export */   \"Rectangle\": () => (/* binding */ Rectangle),\n/* harmony export */   \"GraphicsAssist\": () => (/* binding */ GraphicsAssist)\n/* harmony export */ });\nclass Point {\r\n    constructor(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    /**\r\n     * 求到另一个点的向量\r\n     */\r\n    getVectorTo(point) {\r\n        return new Vector(point.x - this.x, point.y - this.y);\r\n    }\r\n    /**\r\n     * 向某个方向平移\r\n     * @param vector 平移向量\r\n     */\r\n    translate(vector) {\r\n        this.x += vector.x;\r\n        this.y += vector.y;\r\n    }\r\n}\r\nclass Vector {\r\n    constructor(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    /**\r\n     * 向量点积\r\n     */\r\n    static dotProduct(vec1, vec2) {\r\n        return vec1.x * vec2.x + vec1.y * vec2.y;\r\n    }\r\n    /**\r\n     * 向量乘积\r\n     * 注意：向量的乘积本质上是一个矢量，但是这里适用于二维向量，求得结果是向量的模长。\r\n     */\r\n    static multiProduct_Len(vec1, vec2) {\r\n        return Math.abs(vec1.x * vec2.y - vec1.y * vec2.x);\r\n    }\r\n    /**\r\n     * 缩放该向量\r\n     * @param times 缩放倍数\r\n     */\r\n    scale(times) {\r\n        const polar = GraphicsAssist.cartesianToPolar(new Point(this.x, this.y));\r\n        polar.length *= times;\r\n        const point = GraphicsAssist.polarToCartesian(polar);\r\n        this.x = point.x;\r\n        this.y = point.y;\r\n    }\r\n    /**\r\n     * 求单位向量\r\n     */\r\n    normalize() {\r\n        const l = Math.sqrt(this.x * this.x + this.y * this.y);\r\n        return new Vector(this.x / l, this.y / l);\r\n    }\r\n}\r\n/**\r\n * 矩形区域，高和宽可以为负数\r\n */\r\nclass Rectangle {\r\n    /**\r\n     * @param location 矩形的位置，左上角坐标\r\n     * @param w 矩形的宽度\r\n     * @param h 矩形的高度\r\n     */\r\n    constructor(location, w, h) {\r\n        this.location = location;\r\n        this.angle = 0;\r\n        this._width = w;\r\n        this._height = h;\r\n    }\r\n    get width() {\r\n        return this._width;\r\n    }\r\n    get height() {\r\n        return this._height;\r\n    }\r\n    /**\r\n     * 左上角点\r\n     */\r\n    get lt() {\r\n        const lt_normal = new Point(this.location.x - this.width * 0.5, this.location.y - this.height * 0.5);\r\n        return GraphicsAssist.rotatePoint(this.location, lt_normal, this.angle);\r\n    }\r\n    /**\r\n     * 左下角点\r\n     */\r\n    get ld() {\r\n        const ld_normal = new Point(this.location.x - this.width * 0.5, this.location.y + this.height * 0.5);\r\n        return GraphicsAssist.rotatePoint(this.location, ld_normal, this.angle);\r\n    }\r\n    /**\r\n     * 右上角点\r\n     */\r\n    get rt() {\r\n        const rt_normal = new Point(this.location.x + this.width * 0.5, this.location.y - this.height * 0.5);\r\n        return GraphicsAssist.rotatePoint(this.location, rt_normal, this.angle);\r\n    }\r\n    /**\r\n     * 右下角点\r\n     */\r\n    get rd() {\r\n        const rd_normal = new Point(this.location.x + this.width * 0.5, this.location.y + this.height * 0.5);\r\n        return GraphicsAssist.rotatePoint(this.location, rd_normal, this.angle);\r\n    }\r\n    /**\r\n     * 求一组Point构成的包围框\r\n     * @param points 点数组\r\n     */\r\n    static bound(points) {\r\n        if (points.length <= 1) {\r\n            throw new Error(\"Point的个数不能小于2\");\r\n        }\r\n        let max_x = points[0].x;\r\n        let max_y = points[0].y;\r\n        let min_x = points[0].x;\r\n        let min_y = points[0].y;\r\n        for (let i = 1; i < points.length; i++) {\r\n            max_x = Math.max(max_x, points[i].x);\r\n            max_y = Math.max(max_y, points[i].y);\r\n            min_x = Math.min(min_x, points[i].x);\r\n            min_y = Math.min(min_y, points[i].y);\r\n        }\r\n        const lt = new Point(min_x, min_y);\r\n        const w = max_x - min_x;\r\n        const h = max_y - min_y;\r\n        return new Rectangle(new Point(lt.x + w * 0.5, lt.y + h * 0.5), w, h);\r\n    }\r\n    /**\r\n     * 求一组Rectangle构成的包围框矩形\r\n     * @param rects 一组矩形\r\n     */\r\n    static union(rects) {\r\n        if (rects.length < 1) {\r\n            throw new Error(\"Rectangle的个数不能小于1\");\r\n        }\r\n        const points = [];\r\n        for (let i = 0; i < rects.length; i++) {\r\n            points.push(rects[i].lt, rects[i].ld, rects[i].rt, rects[i].rd);\r\n        }\r\n        return Rectangle.bound(points);\r\n    }\r\n    /**\r\n     * 判断两个矩形是否相交\r\n     */\r\n    static intersection(rect1, rect2) {\r\n        if (rect1.height === 0 || rect1.width === 0 || rect2.height === 0 || rect1.width === 0) {\r\n            // 非矩形的情况\r\n            return false;\r\n        }\r\n        const isLtInRect = GraphicsAssist.isPointInRectangle(rect1.lt, rect2);\r\n        const isLdInRect = GraphicsAssist.isPointInRectangle(rect1.ld, rect2);\r\n        const isRdInRect = GraphicsAssist.isPointInRectangle(rect1.rd, rect2);\r\n        const isRtInRect = GraphicsAssist.isPointInRectangle(rect1.rt, rect2);\r\n        const isLtInRect2 = GraphicsAssist.isPointInRectangle(rect2.lt, rect1);\r\n        const isLdInRect2 = GraphicsAssist.isPointInRectangle(rect2.ld, rect1);\r\n        const isRdInRect2 = GraphicsAssist.isPointInRectangle(rect2.rd, rect1);\r\n        const isRtInRect2 = GraphicsAssist.isPointInRectangle(rect2.rt, rect1);\r\n        return isLtInRect || isLdInRect || isRdInRect || isRtInRect || isLtInRect2 || isLdInRect2 || isRdInRect2 || isRtInRect2;\r\n    }\r\n    ;\r\n}\r\nvar GraphicsAssist;\r\n(function (GraphicsAssist) {\r\n    /**\r\n     * 求两个点的中点\r\n     */\r\n    GraphicsAssist.mid = (point1, point2) => {\r\n        return new Point(0.5 * (point1.x + point2.x), 0.5 * (point1.y + point2.y));\r\n    };\r\n    /**\r\n     * 判断点是否处于一个矩形中\r\n     */\r\n    GraphicsAssist.isPointInRectangle = (point, rect) => {\r\n        const vectLtp = rect.lt.getVectorTo(point);\r\n        const vectRtp = rect.rt.getVectorTo(point);\r\n        const vectLdp = rect.ld.getVectorTo(point);\r\n        const vectRdp = rect.rd.getVectorTo(point);\r\n        const vectLtp_normal = vectLtp.normalize();\r\n        const vectRtp_normal = vectRtp.normalize();\r\n        const vectLdp_normal = vectLdp.normalize();\r\n        const vectRdp_normal = vectRdp.normalize();\r\n        // 1.判断point是否处于rect的边界上\r\n        // 上边界\r\n        if (vectLtp_normal.x === -vectRtp_normal.x && vectLtp_normal.y === -vectRtp_normal.y) {\r\n            return true;\r\n        }\r\n        // 左边界\r\n        if (vectLtp_normal.x === -vectLdp_normal.x && vectLtp_normal.y === -vectLdp_normal.y) {\r\n            return true;\r\n        }\r\n        // 下边界\r\n        if (vectLdp_normal.x === -vectRdp_normal.x && vectLdp_normal.y === -vectRdp_normal.y) {\r\n            return true;\r\n        }\r\n        // 右边界\r\n        if (vectRtp_normal.x === -vectRdp_normal.x && vectRtp_normal.y === -vectRdp_normal.y) {\r\n            return true;\r\n        }\r\n        // 2.判断point是否处于rect的内部，通过求面积法。如果点位于矩形内部，那么由点和矩形四个点构成的四个三角形总面积必定等于矩形的面积\r\n        const area1 = Vector.multiProduct_Len(vectLtp, vectLdp) * 0.5;\r\n        const area2 = Vector.multiProduct_Len(vectLdp, vectRdp) * 0.5;\r\n        const area3 = Vector.multiProduct_Len(vectRdp, vectRtp) * 0.5;\r\n        const area4 = Vector.multiProduct_Len(vectLtp, vectRtp) * 0.5;\r\n        const areaRect = rect.height * rect.width;\r\n        // 精度控制在0.1\r\n        if (Math.abs(area1 + area2 + area3 + area4 - areaRect) < 0.1) {\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * 笛卡尔坐标转极坐标\r\n     */\r\n    GraphicsAssist.cartesianToPolar = (point) => {\r\n        const length = Math.sqrt(point.x * point.x + point.y * point.y);\r\n        const angle = Math.atan2(point.y, point.x);\r\n        return { length, angle };\r\n    };\r\n    /**\r\n     * 极坐标转笛卡尔\r\n     */\r\n    GraphicsAssist.polarToCartesian = (point) => {\r\n        const x = Math.cos(point.angle) * point.length;\r\n        const y = Math.sin(point.angle) * point.length;\r\n        return new Point(x, y);\r\n    };\r\n    /**\r\n     * 将一个点，绕着另一个点旋转一定的角度\r\n     * @param origin 旋转中心\r\n     * @param point 旋转点\r\n     * @param anticlockwiseAngle 旋转角度\r\n     */\r\n    GraphicsAssist.rotatePoint = (origin, point, anticlockwiseAngle) => {\r\n        const p1 = new Point(point.x - origin.x, point.y - origin.y);\r\n        const p1_polar = GraphicsAssist.cartesianToPolar(p1);\r\n        const p1_polar_rotate = {\r\n            length: p1_polar.length,\r\n            angle: p1_polar.angle - anticlockwiseAngle // 因为屏幕坐标系Y轴向上，所以这里用减法\r\n        };\r\n        const p1_rotate = GraphicsAssist.polarToCartesian(p1_polar_rotate);\r\n        return new Point(p1_rotate.x + origin.x, p1_rotate.y + origin.y);\r\n    };\r\n    /**\r\n     * 计算该角度（弧度）下的单位向量\r\n     * @param angle 角度（弧度）\r\n     */\r\n    GraphicsAssist.getNormalVectorByAngle = (angle) => {\r\n        const polar = {\r\n            angle: angle,\r\n            length: 1\r\n        };\r\n        const point = GraphicsAssist.polarToCartesian(polar);\r\n        return new Vector(point.x, point.y);\r\n    };\r\n})(GraphicsAssist || (GraphicsAssist = {}));\r\n\n\n//# sourceURL=webpack://GlobalMiracle/./src/graphic.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _mouse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mouse */ \"./src/mouse.ts\");\n\r\nclass Miracle {\r\n    constructor(canvas, entities = []) {\r\n        this.entities = entities;\r\n        this.low_canvas = canvas;\r\n        const parentElement = canvas.parentElement;\r\n        this.up_canvas = null;\r\n        if (parentElement) {\r\n            parentElement.removeChild(canvas);\r\n            this.up_canvas = canvas.cloneNode(true);\r\n            const canvasContainer = document.createElement(\"div\");\r\n            canvasContainer.style.backgroundColor = \"transparent\";\r\n            canvasContainer.style.display = \"relative\";\r\n            canvasContainer.style.height = canvas.style.height;\r\n            canvasContainer.style.width = canvas.style.width;\r\n            canvasContainer.style.display = \"inline-block\";\r\n            canvasContainer.style.border = canvas.style.border;\r\n            canvasContainer.className = \"miracle-container\";\r\n            this.up_canvas.style.position = \"absolute\";\r\n            this.up_canvas.style.left = \"0\";\r\n            this.up_canvas.style.top = \"0\";\r\n            this.up_canvas.style.backgroundColor = \"transparent\";\r\n            this.up_canvas.className = `up-canvas ${this.up_canvas.className}`;\r\n            this.low_canvas.style.position = \"absolute\";\r\n            this.low_canvas.style.left = \"0\";\r\n            this.low_canvas.style.top = \"0\";\r\n            this.low_canvas.className = `lower-canvas ${this.low_canvas.className}`;\r\n            canvasContainer.appendChild(this.low_canvas);\r\n            canvasContainer.appendChild(this.up_canvas);\r\n            parentElement.appendChild(canvasContainer);\r\n            this.mouseControl = new _mouse__WEBPACK_IMPORTED_MODULE_0__.default(this.entities, this.up_canvas);\r\n        }\r\n    }\r\n    /**\r\n     * 当前canvas的视口\r\n     */\r\n    get viewport() {\r\n        if (this.up_canvas) {\r\n            return {\r\n                height: this.up_canvas.height,\r\n                width: this.up_canvas.width\r\n            };\r\n        }\r\n        return { height: 0, width: 0 };\r\n    }\r\n    /**\r\n     * x方向缩放是否禁用\r\n     */\r\n    set xLocked(value) {\r\n        this.entities.forEach((ent) => ent.xLocked = value);\r\n    }\r\n    /**\r\n     * y方向缩放是否禁用\r\n     */\r\n    set yLocked(value) {\r\n        this.entities.forEach((ent) => ent.yLocked = value);\r\n    }\r\n    /**\r\n     * 对角线缩放是否禁用\r\n     */\r\n    set diagLocked(value) {\r\n        this.entities.forEach((ent) => ent.diagLocked = value);\r\n    }\r\n    /**\r\n     *  旋转是否禁用\r\n     */\r\n    set rotateLocked(value) {\r\n        this.entities.forEach((ent) => ent.rotateLocked = value);\r\n    }\r\n    dispose() {\r\n        if (this.up_canvas) {\r\n            const canvasContainer = this.up_canvas.parentElement;\r\n            if (canvasContainer) {\r\n                canvasContainer.removeChild(this.up_canvas);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 添加entity\r\n     */\r\n    addEntity(...entities) {\r\n        var _a;\r\n        this.entities.push(...entities);\r\n        const ctx = (_a = this.up_canvas) === null || _a === void 0 ? void 0 : _a.getContext(\"2d\");\r\n        if (ctx) {\r\n            for (let i = 0; i < entities.length; i++) {\r\n                this.entities[i].draw(ctx);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 重绘\r\n     */\r\n    redraw() {\r\n        var _a;\r\n        const ctx = (_a = this.up_canvas) === null || _a === void 0 ? void 0 : _a.getContext(\"2d\");\r\n        if (ctx) {\r\n            ctx.clearRect(-2, -2, ctx.canvas.clientWidth + 4, ctx.canvas.clientHeight + 4);\r\n            for (let i = 0; i < this.entities.length; i++) {\r\n                this.entities[i].draw(ctx);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 获得当前激活的、可见的entity\r\n     */\r\n    getActiveEntities() {\r\n        return this.entities.filter((ent) => ent.visible && ent.isActive);\r\n    }\r\n    /**\r\n     * 删除一个entity\r\n     */\r\n    removeEntity(...entities) {\r\n        for (let i = 0; i < entities.length; i++) {\r\n            const entity = entities[i];\r\n            const index = this.entities.indexOf(entity);\r\n            if (index > -1) {\r\n                this.entities.splice(index, 1);\r\n                this.redraw();\r\n            }\r\n            else {\r\n                throw new Error(\"要删除的entity，不存在。\");\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 删除所有entity，清空画布\r\n     */\r\n    removeAll() {\r\n        while (this.entities.length > 0) {\r\n            this.entities.pop();\r\n        }\r\n        this.redraw();\r\n    }\r\n    /**\r\n     * 转换成图片base64 dataurl\r\n     * @param scale 在当前大小的基础上在缩放一个比例值\r\n     * @param type （与HTMLCanvasElement.toDataURL的第一个参数相同）图片格式\r\n     * @param quality （与HTMLCanvasElement.toDataURL的第二个参数相同）在指定图片格式为 image/jpeg 或 image/webp的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 0.92。\r\n     */\r\n    toDataUrl(type, scale, quality) {\r\n        if (this.up_canvas) {\r\n            const canvas = this.up_canvas.cloneNode();\r\n            if (scale) {\r\n                canvas.style.height = `${scale.y * this.viewport.height}px`;\r\n                canvas.style.width = `${scale.x * this.viewport.width}px`;\r\n                canvas.height = scale.y * this.viewport.height;\r\n                canvas.width = scale.x * this.viewport.width;\r\n            }\r\n            const ctx = canvas.getContext(\"2d\");\r\n            if (scale) {\r\n                ctx === null || ctx === void 0 ? void 0 : ctx.scale(scale.x, scale.y);\r\n            }\r\n            if (ctx) {\r\n                ctx.drawImage(this.up_canvas, 0, 0);\r\n                return canvas.toDataURL(type, quality);\r\n            }\r\n        }\r\n    }\r\n}\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Miracle);\r\n\n\n//# sourceURL=webpack://GlobalMiracle/./src/index.ts?");

/***/ }),

/***/ "./src/mouse.ts":
/*!**********************!*\
  !*** ./src/mouse.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Operator\": () => (/* binding */ Operator),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./entity */ \"./src/entity.ts\");\n/* harmony import */ var _graphic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./graphic */ \"./src/graphic.ts\");\n\r\n\r\nvar Operator;\r\n(function (Operator) {\r\n    /**\r\n     * 框选操作\r\n     */\r\n    Operator[Operator[\"BoxSelect\"] = 1] = \"BoxSelect\";\r\n    /**\r\n     * 点击自定义按钮\r\n     */\r\n    Operator[Operator[\"ControlClick\"] = 2] = \"ControlClick\";\r\n    /**\r\n     * 旋转entity\r\n     */\r\n    Operator[Operator[\"RotateEntity\"] = 3] = \"RotateEntity\";\r\n    /**\r\n     * 移动Entity\r\n     */\r\n    Operator[Operator[\"MoveEntity\"] = 4] = \"MoveEntity\";\r\n    /**\r\n     * 改变entity大小，左上\r\n     */\r\n    Operator[Operator[\"ChangeEntitySizeLt\"] = 5] = \"ChangeEntitySizeLt\";\r\n    /**\r\n     * 改变entity大小，左中\r\n     */\r\n    Operator[Operator[\"ChangeEntitySizeLm\"] = 6] = \"ChangeEntitySizeLm\";\r\n    /**\r\n     * 改变entity大小，左下\r\n     */\r\n    Operator[Operator[\"ChangeEntitySizeLb\"] = 7] = \"ChangeEntitySizeLb\";\r\n    /**\r\n     * 改变entity大小，中下\r\n     */\r\n    Operator[Operator[\"ChangeEntitySizeMb\"] = 8] = \"ChangeEntitySizeMb\";\r\n    /**\r\n     * 改变entity大小，右下\r\n     */\r\n    Operator[Operator[\"ChangeEntitySizeRb\"] = 9] = \"ChangeEntitySizeRb\";\r\n    /**\r\n     * 改变entity大小，右中\r\n     */\r\n    Operator[Operator[\"ChangeEntitySizeRm\"] = 10] = \"ChangeEntitySizeRm\";\r\n    /**\r\n     * 改变entity大小，右上\r\n     */\r\n    Operator[Operator[\"ChangeEntitySizeRt\"] = 11] = \"ChangeEntitySizeRt\";\r\n    /**\r\n     * 改变entity大小，中上\r\n     */\r\n    Operator[Operator[\"ChangeEntitySizeMt\"] = 12] = \"ChangeEntitySizeMt\";\r\n})(Operator || (Operator = {}));\r\nclass MiracleMouseControl {\r\n    constructor(entities, canvas) {\r\n        this.dragging = false; // 是否正在拖拽\r\n        this.operator = Operator.BoxSelect; // 用户此时的操作类型\r\n        //#region mouse move操作，涉及的变化\r\n        /**\r\n         * 绘制动态框选框\r\n         */\r\n        this.drawSelectBox = (event) => {\r\n            this.dynamicRect = {\r\n                lt: this.dynamicRect.lt,\r\n                rd: new _graphic__WEBPACK_IMPORTED_MODULE_1__.Point(event.offsetX, event.offsetY)\r\n            };\r\n            this.redraw();\r\n        };\r\n        /**\r\n         * 移动entity时，动态绘制图元\r\n         */\r\n        this.MoveEntity = (event) => {\r\n            const activeEntities = this.getActiveEntities();\r\n            for (let i = 0; i < activeEntities.length; i++) {\r\n                activeEntities[i].displacement(new _graphic__WEBPACK_IMPORTED_MODULE_1__.Vector(event.movementX, event.movementY));\r\n            }\r\n            this.redraw();\r\n        };\r\n        /**\r\n         * 改变entity尺寸\r\n         */\r\n        this.resizeEntity = (event) => {\r\n            const activeEntities = this.getActiveEntities();\r\n            if (activeEntities.length > 0) {\r\n                let boundD;\r\n                if (this.activeCollection) {\r\n                    boundD = this.activeCollection.bound;\r\n                }\r\n                else {\r\n                    const entity = activeEntities[0];\r\n                    boundD = entity.bound;\r\n                }\r\n                if (this.operator === Operator.ChangeEntitySizeLt) {\r\n                    const origin = boundD.rd;\r\n                    const cursorDisToOrigin = Math.sqrt(Math.pow(event.offsetX - origin.x, 2) + Math.pow(event.offsetY - origin.y, 2));\r\n                    const zoomScale = cursorDisToOrigin / Math.sqrt(Math.pow(boundD.lt.x - boundD.rd.x, 2) + Math.pow(boundD.lt.y - boundD.rd.y, 2));\r\n                    for (let i = 0; i < activeEntities.length; i++) {\r\n                        activeEntities[i].zoom(origin, zoomScale);\r\n                    }\r\n                }\r\n                else if (this.operator === Operator.ChangeEntitySizeLm) {\r\n                    const origin = _graphic__WEBPACK_IMPORTED_MODULE_1__.GraphicsAssist.mid(boundD.rt, boundD.rd);\r\n                    const cursorDisToOrigin = Math.sqrt(Math.pow(event.offsetX - origin.x, 2) + Math.pow(event.offsetY - origin.y, 2));\r\n                    const zoomScale = cursorDisToOrigin / Math.sqrt(Math.pow(boundD.lt.x - boundD.rt.x, 2) + Math.pow(boundD.lt.y - boundD.rt.y, 2));\r\n                    for (let i = 0; i < activeEntities.length; i++) {\r\n                        activeEntities[i].zoomX(origin, zoomScale);\r\n                    }\r\n                }\r\n                else if (this.operator === Operator.ChangeEntitySizeLb) {\r\n                    const origin = boundD.rt;\r\n                    const cursorDisToOrigin = Math.sqrt(Math.pow(event.offsetX - origin.x, 2) + Math.pow(event.offsetY - origin.y, 2));\r\n                    const zoomScale = cursorDisToOrigin / Math.sqrt(Math.pow(boundD.ld.x - boundD.rt.x, 2) + Math.pow(boundD.ld.y - boundD.rt.y, 2));\r\n                    for (let i = 0; i < activeEntities.length; i++) {\r\n                        activeEntities[i].zoom(origin, zoomScale);\r\n                    }\r\n                }\r\n                else if (this.operator === Operator.ChangeEntitySizeMb) {\r\n                    const origin = _graphic__WEBPACK_IMPORTED_MODULE_1__.GraphicsAssist.mid(boundD.lt, boundD.rt);\r\n                    const cursorDisToOrigin = Math.sqrt(Math.pow(event.offsetX - origin.x, 2) + Math.pow(event.offsetY - origin.y, 2));\r\n                    const zoomScale = cursorDisToOrigin / Math.sqrt(Math.pow(boundD.lt.x - boundD.ld.x, 2) + Math.pow(boundD.lt.y - boundD.ld.y, 2));\r\n                    for (let i = 0; i < activeEntities.length; i++) {\r\n                        activeEntities[i].zoomY(origin, zoomScale);\r\n                    }\r\n                }\r\n                else if (this.operator === Operator.ChangeEntitySizeRb) {\r\n                    const origin = boundD.lt;\r\n                    const cursorDisToOrigin = Math.sqrt(Math.pow(event.offsetX - origin.x, 2) + Math.pow(event.offsetY - origin.y, 2));\r\n                    const zoomScale = cursorDisToOrigin / Math.sqrt(Math.pow(boundD.lt.x - boundD.rd.x, 2) + Math.pow(boundD.lt.y - boundD.rd.y, 2));\r\n                    for (let i = 0; i < activeEntities.length; i++) {\r\n                        activeEntities[i].zoom(origin, zoomScale);\r\n                    }\r\n                }\r\n                else if (this.operator === Operator.ChangeEntitySizeRm) {\r\n                    const origin = _graphic__WEBPACK_IMPORTED_MODULE_1__.GraphicsAssist.mid(boundD.lt, boundD.ld);\r\n                    const cursorDisToOrigin = Math.sqrt(Math.pow(event.offsetX - origin.x, 2) + Math.pow(event.offsetY - origin.y, 2));\r\n                    const zoomScale = cursorDisToOrigin / Math.sqrt(Math.pow(boundD.lt.x - boundD.rt.x, 2) + Math.pow(boundD.lt.y - boundD.rt.y, 2));\r\n                    for (let i = 0; i < activeEntities.length; i++) {\r\n                        activeEntities[i].zoomX(origin, zoomScale);\r\n                    }\r\n                }\r\n                else if (this.operator === Operator.ChangeEntitySizeRt) {\r\n                    const origin = boundD.ld;\r\n                    const cursorDisToOrigin = Math.sqrt(Math.pow(event.offsetX - origin.x, 2) + Math.pow(event.offsetY - origin.y, 2));\r\n                    const zoomScale = cursorDisToOrigin / Math.sqrt(Math.pow(boundD.lt.x - boundD.rd.x, 2) + Math.pow(boundD.lt.y - boundD.rd.y, 2));\r\n                    for (let i = 0; i < activeEntities.length; i++) {\r\n                        activeEntities[i].zoom(origin, zoomScale);\r\n                    }\r\n                }\r\n                else if (this.operator === Operator.ChangeEntitySizeMt) {\r\n                    const origin = _graphic__WEBPACK_IMPORTED_MODULE_1__.GraphicsAssist.mid(boundD.ld, boundD.rd);\r\n                    const cursorDisToOrigin = Math.sqrt(Math.pow(event.offsetX - origin.x, 2) + Math.pow(event.offsetY - origin.y, 2));\r\n                    const zoomScale = cursorDisToOrigin / Math.sqrt(Math.pow(boundD.lt.x - boundD.ld.x, 2) + Math.pow(boundD.lt.y - boundD.ld.y, 2));\r\n                    for (let i = 0; i < activeEntities.length; i++) {\r\n                        activeEntities[i].zoomY(origin, zoomScale);\r\n                    }\r\n                }\r\n                this.redraw();\r\n            }\r\n        };\r\n        this.rotateEntity = (event) => {\r\n            const activeEntities = this.getActiveEntities();\r\n            if (activeEntities.length > 0) {\r\n                for (let i = 0; i < activeEntities.length; i++) {\r\n                    const boundD = activeEntities[i].bound;\r\n                    const rotateOrigin = boundD.location;\r\n                    const rotateControlBoundD = activeEntities[i].getControlPointBound_rotate_device();\r\n                    const point1 = rotateControlBoundD.location;\r\n                    const point11 = new _graphic__WEBPACK_IMPORTED_MODULE_1__.Point(point1.x - rotateOrigin.x, point1.y - rotateOrigin.y);\r\n                    const point11Polar = _graphic__WEBPACK_IMPORTED_MODULE_1__.GraphicsAssist.cartesianToPolar(point11);\r\n                    const point2 = new _graphic__WEBPACK_IMPORTED_MODULE_1__.Point(event.offsetX, event.offsetY);\r\n                    const point22 = new _graphic__WEBPACK_IMPORTED_MODULE_1__.Point(point2.x - rotateOrigin.x, point2.y - rotateOrigin.y);\r\n                    const point22Polar = _graphic__WEBPACK_IMPORTED_MODULE_1__.GraphicsAssist.cartesianToPolar(point22);\r\n                    const rotateAngle = point22Polar.angle - point11Polar.angle;\r\n                    activeEntities[i].rotateAnticlockwise(-rotateAngle);\r\n                }\r\n            }\r\n            this.redraw();\r\n        };\r\n        //#endregion\r\n        //#region 鼠标操作\r\n        /**\r\n         * 1.设置鼠标样式\r\n         * 2.根据鼠标位置，判断鼠标操作的类型\r\n         */\r\n        this.onMouseMove_setOperator = (event) => {\r\n            if (this.dragging === false) {\r\n                this.operator = Operator.BoxSelect;\r\n                this.mouseHoveEntity = undefined;\r\n                const mousePoint = new _graphic__WEBPACK_IMPORTED_MODULE_1__.Point(event.offsetX, event.offsetY);\r\n                document.body.style.cursor = \"auto\";\r\n                const activeEntities = this.getActiveEntities();\r\n                // 判断是否处于控制点内\r\n                if (activeEntities.length > 0) {\r\n                    let entity;\r\n                    if (activeEntities.length > 1) {\r\n                        entity = this.activeCollection;\r\n                    }\r\n                    else {\r\n                        entity = activeEntities[0];\r\n                    }\r\n                    const isMouseInControlBound = (ctrBoundD) => {\r\n                        if (_graphic__WEBPACK_IMPORTED_MODULE_1__.GraphicsAssist.isPointInRectangle(mousePoint, ctrBoundD)) {\r\n                            return true;\r\n                        }\r\n                        return false;\r\n                    };\r\n                    if (!entity.diagLocked) {\r\n                        // 左上角控制点\r\n                        const ltCtrBoundD = entity.getControlPointBound_lt_device();\r\n                        if (isMouseInControlBound(ltCtrBoundD)) {\r\n                            document.body.style.cursor = \"pointer\";\r\n                            this.operator = Operator.ChangeEntitySizeLt;\r\n                            return;\r\n                        }\r\n                        // 左下\r\n                        const lbCtrBoundD = entity.getControlPointBound_lb_device();\r\n                        if (isMouseInControlBound(lbCtrBoundD)) {\r\n                            document.body.style.cursor = \"pointer\";\r\n                            this.operator = Operator.ChangeEntitySizeLb;\r\n                            return;\r\n                        }\r\n                        // 右下\r\n                        const RbCtrBoundD = entity.getControlPointBound_rb_device();\r\n                        if (isMouseInControlBound(RbCtrBoundD)) {\r\n                            document.body.style.cursor = \"pointer\";\r\n                            this.operator = Operator.ChangeEntitySizeRb;\r\n                            return;\r\n                        }\r\n                        // 右上\r\n                        const RtCtrBoundD = entity.getControlPointBound_rt_device();\r\n                        if (isMouseInControlBound(RtCtrBoundD)) {\r\n                            document.body.style.cursor = \"pointer\";\r\n                            this.operator = Operator.ChangeEntitySizeRt;\r\n                            return;\r\n                        }\r\n                    }\r\n                    if (!entity.xLocked) {\r\n                        // 左中\r\n                        const lmCtrBoundD = entity.getControlPointBound_lm_device();\r\n                        if (isMouseInControlBound(lmCtrBoundD)) {\r\n                            document.body.style.cursor = \"pointer\";\r\n                            this.operator = Operator.ChangeEntitySizeLm;\r\n                            return;\r\n                        }\r\n                        // 右中\r\n                        const RmCtrBoundD = entity.getControlPointBound_rm_device();\r\n                        if (isMouseInControlBound(RmCtrBoundD)) {\r\n                            document.body.style.cursor = \"pointer\";\r\n                            this.operator = Operator.ChangeEntitySizeRm;\r\n                            return;\r\n                        }\r\n                    }\r\n                    if (!entity.yLocked) {\r\n                        // 中下\r\n                        const MbCtrBoundD = entity.getControlPointBound_bm_device();\r\n                        if (isMouseInControlBound(MbCtrBoundD)) {\r\n                            document.body.style.cursor = \"pointer\";\r\n                            this.operator = Operator.ChangeEntitySizeMb;\r\n                            return;\r\n                        }\r\n                        // 中上\r\n                        const MtCtrBoundD = entity.getControlPointBound_tm_device();\r\n                        if (isMouseInControlBound(MtCtrBoundD)) {\r\n                            document.body.style.cursor = \"pointer\";\r\n                            this.operator = Operator.ChangeEntitySizeMt;\r\n                            return;\r\n                        }\r\n                    }\r\n                    if (!entity.rotateLocked) {\r\n                        // 旋转点\r\n                        const rotateCtrBoundD = entity.getControlPointBound_rotate_device();\r\n                        if (isMouseInControlBound(rotateCtrBoundD)) {\r\n                            document.body.style.cursor = \"crosshair\";\r\n                            this.operator = Operator.RotateEntity;\r\n                            return;\r\n                        }\r\n                    }\r\n                    if (entity.isDrawControlPoint) {\r\n                        // 点击自定义按钮\r\n                        for (let i = 0; i < entity.controls.length; i++) {\r\n                            const control = entity.controls[i];\r\n                            const controlBound = control.bound();\r\n                            if (isMouseInControlBound(controlBound)) {\r\n                                document.body.style.cursor = control.cursorStyle;\r\n                                this.operator = Operator.ControlClick;\r\n                                return;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (this.activeCollection) {\r\n                    const boundD = this.activeCollection.bound;\r\n                    if (_graphic__WEBPACK_IMPORTED_MODULE_1__.GraphicsAssist.isPointInRectangle(mousePoint, boundD)) {\r\n                        document.body.style.cursor = \"move\";\r\n                        this.operator = Operator.MoveEntity;\r\n                        return;\r\n                    }\r\n                }\r\n                for (let i = 0; i < this.visibleEntities.length; i++) {\r\n                    const ent = this.visibleEntities[i];\r\n                    const boundD = ent.bound;\r\n                    // // 测试 ---绘制屏幕包围框\r\n                    // const ctx = this.canvas.getContext(\"2d\");\r\n                    // if (ctx) {\r\n                    //     ctx.strokeStyle = \"gray\";\r\n                    //     ctx.beginPath();\r\n                    //     ctx.moveTo(boundD.lt.x, boundD.lt.y);\r\n                    //     ctx.lineTo(boundD.ld.x, boundD.ld.y);\r\n                    //     ctx.lineTo(boundD.rd.x, boundD.rd.y);\r\n                    //     ctx.lineTo(boundD.rt.x, boundD.rt.y);\r\n                    //     ctx.closePath();\r\n                    //     ctx.stroke();\r\n                    // }\r\n                    // 鼠标位于entity包围框内，鼠标指针为\"move\"\r\n                    if (_graphic__WEBPACK_IMPORTED_MODULE_1__.GraphicsAssist.isPointInRectangle(mousePoint, boundD)) {\r\n                        document.body.style.cursor = \"move\";\r\n                        this.operator = Operator.MoveEntity;\r\n                        this.mouseHoveEntity = ent;\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        this.onMouseDown = (event) => {\r\n            if (event.button === 0) {\r\n                this.dragging = true;\r\n                this.mouseDownPosition = new _graphic__WEBPACK_IMPORTED_MODULE_1__.Point(event.offsetX, event.offsetY);\r\n                if (this.operator === Operator.MoveEntity) {\r\n                    if (this.getActiveEntities().length > 0) {\r\n                        const boundsD = this.getActiveEntities().map((ent) => ent.bound);\r\n                        const unionBoundD = _graphic__WEBPACK_IMPORTED_MODULE_1__.Rectangle.union(boundsD);\r\n                        if (!_graphic__WEBPACK_IMPORTED_MODULE_1__.GraphicsAssist.isPointInRectangle(this.mouseDownPosition, unionBoundD)) {\r\n                            this.visibleEntities.forEach((ent) => {\r\n                                ent.isActive = false;\r\n                            });\r\n                            if (this.mouseHoveEntity) {\r\n                                this.mouseHoveEntity.isActive = true;\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (this.mouseHoveEntity) {\r\n                            this.mouseHoveEntity.isActive = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (this.operator === Operator.ControlClick) {\r\n                    const isMouseInControlBound = (ctrBoundD) => {\r\n                        const mousePoint = new _graphic__WEBPACK_IMPORTED_MODULE_1__.Point(event.offsetX, event.offsetY);\r\n                        if (_graphic__WEBPACK_IMPORTED_MODULE_1__.GraphicsAssist.isPointInRectangle(mousePoint, ctrBoundD)) {\r\n                            return true;\r\n                        }\r\n                        return false;\r\n                    };\r\n                    const activeEntities = this.getActiveEntities();\r\n                    if (activeEntities.length > 0) {\r\n                        const ent = activeEntities[0];\r\n                        const ctr = ent.controls.find((control) => isMouseInControlBound(control.bound()));\r\n                        ctr === null || ctr === void 0 ? void 0 : ctr.mouseDownHandler(event);\r\n                    }\r\n                }\r\n                if (this.operator === Operator.BoxSelect) {\r\n                    // this.dynamicRect = new Rectangle(this.mouseDownPosition, 0, 0);\r\n                    this.dynamicRect = {\r\n                        lt: this.mouseDownPosition,\r\n                        rd: this.mouseDownPosition\r\n                    };\r\n                    this.visibleEntities.forEach((ent) => {\r\n                        ent.isActive = false;\r\n                    });\r\n                }\r\n                this.redraw();\r\n            }\r\n        };\r\n        this.onMouseMove = (event) => {\r\n            if (this.dragging) {\r\n                switch (this.operator) {\r\n                    case Operator.BoxSelect:\r\n                        this.drawSelectBox(event);\r\n                        break;\r\n                    case Operator.MoveEntity:\r\n                        this.MoveEntity(event);\r\n                        break;\r\n                    case Operator.ChangeEntitySizeLt:\r\n                        this.resizeEntity(event);\r\n                        break;\r\n                    case Operator.ChangeEntitySizeLb:\r\n                        this.resizeEntity(event);\r\n                        break;\r\n                    case Operator.ChangeEntitySizeLm:\r\n                        this.resizeEntity(event);\r\n                        break;\r\n                    case Operator.ChangeEntitySizeMb:\r\n                        this.resizeEntity(event);\r\n                        break;\r\n                    case Operator.ChangeEntitySizeRb:\r\n                        this.resizeEntity(event);\r\n                        break;\r\n                    case Operator.ChangeEntitySizeRm:\r\n                        this.resizeEntity(event);\r\n                        break;\r\n                    case Operator.ChangeEntitySizeRt:\r\n                        this.resizeEntity(event);\r\n                        break;\r\n                    case Operator.ChangeEntitySizeMt:\r\n                        this.resizeEntity(event);\r\n                        break;\r\n                    case Operator.RotateEntity:\r\n                        this.rotateEntity(event);\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n        };\r\n        this.onMouseUp = (event) => {\r\n            if (this.operator === Operator.BoxSelect && this.dynamicRect) {\r\n                for (let i = 0; i < this.visibleEntities.length; i++) {\r\n                    const ent = this.visibleEntities[i];\r\n                    const boundD = ent.bound;\r\n                    const mouseRect = new _graphic__WEBPACK_IMPORTED_MODULE_1__.Rectangle(_graphic__WEBPACK_IMPORTED_MODULE_1__.GraphicsAssist.mid(this.dynamicRect.lt, this.dynamicRect.rd), this.dynamicRect.rd.x - this.dynamicRect.lt.x, this.dynamicRect.rd.y - this.dynamicRect.lt.y);\r\n                    if (_graphic__WEBPACK_IMPORTED_MODULE_1__.Rectangle.intersection(mouseRect, boundD)) {\r\n                        ent.isActive = true;\r\n                    }\r\n                }\r\n            }\r\n            // 自定义控件mouseup事件\r\n            if (this.operator === Operator.ControlClick) {\r\n                const isMouseInControlBound = (ctrBoundD) => {\r\n                    const mousePoint = new _graphic__WEBPACK_IMPORTED_MODULE_1__.Point(event.offsetX, event.offsetY);\r\n                    if (_graphic__WEBPACK_IMPORTED_MODULE_1__.GraphicsAssist.isPointInRectangle(mousePoint, ctrBoundD)) {\r\n                        return true;\r\n                    }\r\n                    return false;\r\n                };\r\n                const activeEntities = this.getActiveEntities();\r\n                if (activeEntities.length > 0) {\r\n                    const ent = activeEntities[0];\r\n                    const ctr = ent.controls.find((control) => isMouseInControlBound(control.bound()));\r\n                    ctr === null || ctr === void 0 ? void 0 : ctr.mouseUpHandler(event);\r\n                }\r\n            }\r\n            // 设置activeEntsCollection\r\n            const activeEnts = this.getActiveEntities();\r\n            if (activeEnts.length > 1) {\r\n                this.activeCollection = new _entity__WEBPACK_IMPORTED_MODULE_0__.EntityCollection(activeEnts);\r\n            }\r\n            else {\r\n                this.activeCollection = undefined;\r\n            }\r\n            this.dragging = false;\r\n            this.dynamicRect = undefined;\r\n            this.redraw();\r\n        };\r\n        this.entities = entities;\r\n        this.canvas = canvas;\r\n        this.initEvent();\r\n    }\r\n    /**\r\n     * 可见的Entity\r\n     */\r\n    get visibleEntities() {\r\n        return this.entities.filter(ent => ent.visible);\r\n    }\r\n    initEvent() {\r\n        this.canvas.addEventListener(\"mousedown\", this.onMouseDown);\r\n        this.canvas.addEventListener(\"mouseup\", this.onMouseUp);\r\n        this.canvas.addEventListener(\"mousemove\", this.onMouseMove);\r\n        this.canvas.addEventListener(\"mousemove\", this.onMouseMove_setOperator);\r\n    }\r\n    redraw() {\r\n        const ctx = this.canvas.getContext(\"2d\");\r\n        if (ctx) {\r\n            // 绘制动态矩形\r\n            ctx.clearRect(0, 0, this.canvas.clientWidth, this.canvas.clientHeight);\r\n            ctx.setLineDash([]);\r\n            const drawControlPoint_store = [];\r\n            const drawControl_store = [];\r\n            // 存储属性值\r\n            for (let i = 0; i < this.visibleEntities.length; i++) {\r\n                drawControlPoint_store.push(this.visibleEntities[i].isDrawControlPoint);\r\n                drawControl_store.push(this.visibleEntities[i].isDrawControl);\r\n            }\r\n            // 绘制entity\r\n            const activeEntities = this.getActiveEntities();\r\n            if (activeEntities.length > 1) {\r\n                const collection = new _entity__WEBPACK_IMPORTED_MODULE_0__.EntityCollection(activeEntities);\r\n                collection.isActive = true;\r\n                collection.isDrawControlPoint = true;\r\n                activeEntities.forEach((ent) => {\r\n                    ent.isDrawControlPoint = false;\r\n                    ent.isDrawControl = false;\r\n                });\r\n                for (let i = 0; i < this.visibleEntities.length; i++) {\r\n                    const entity = this.visibleEntities[i];\r\n                    if (!activeEntities.includes(entity)) {\r\n                        entity.draw(ctx);\r\n                    }\r\n                }\r\n                collection.draw(ctx);\r\n            }\r\n            else {\r\n                for (let i = 0; i < this.visibleEntities.length; i++) {\r\n                    const entity = this.visibleEntities[i];\r\n                    entity.draw(ctx);\r\n                }\r\n            }\r\n            // 绘制动态矩形\r\n            if (this.operator === Operator.BoxSelect && this.dynamicRect) {\r\n                const dynaimcRect = this.dynamicRect;\r\n                ctx.setLineDash([6]);\r\n                ctx.strokeStyle = \"black\";\r\n                ctx.beginPath();\r\n                ctx.strokeRect(dynaimcRect.lt.x, dynaimcRect.lt.y, dynaimcRect.rd.x - dynaimcRect.lt.x, dynaimcRect.rd.y - dynaimcRect.lt.y);\r\n            }\r\n            // 恢复属性值\r\n            for (let i = 0; i < this.visibleEntities.length; i++) {\r\n                this.visibleEntities[i].isDrawControlPoint = drawControlPoint_store[i];\r\n                this.visibleEntities[i].isDrawControl = drawControl_store[i];\r\n            }\r\n        }\r\n    }\r\n    //#endregion\r\n    getActiveEntities() {\r\n        return this.visibleEntities.filter((ent) => ent.isActive);\r\n    }\r\n}\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MiracleMouseControl);\r\n\n\n//# sourceURL=webpack://GlobalMiracle/./src/mouse.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	GlobalMiracle = __webpack_exports__;
/******/ 	
/******/ })()
;